{"version":3,"sources":["../../src/redux/promiseMiddleware.js"],"names":["promiseMiddleware","getState","dispatch","action","promise","next","type","payload","rest","newAction","initialType","undefined","initialPayload","then","result","console","error"],"mappings":";;;;;;;;kBAUwBA,iB;;;;AAVxB;;;;AAIA;;;;;;AAMe,SAASA,iBAAT,OAAiD;AAAA,QAArBC,QAAqB,QAArBA,QAAqB;AAAA,QAAXC,QAAW,QAAXA,QAAW;;AAC5D,WAAO;AAAA,eAAQ,kBAAU;;AAErB;AACA;AACA,gBAAI,CAACC,OAAOC,OAAZ,EAAqB;AACjB,uBAAOC,KAAKF,MAAL,CAAP;AACH,aAFD,MAEO;AACH;AACAE,qBAAKF,MAAL;;AAFG,oBAIIG,IAJJ,GAIuCH,MAJvC,CAIIG,IAJJ;AAAA,oBAIUF,OAJV,GAIuCD,MAJvC,CAIUC,OAJV;AAAA,oBAImBG,OAJnB,GAIuCJ,MAJvC,CAImBI,OAJnB;AAAA,oBAI+BC,IAJ/B,4BAIuCL,MAJvC;;AAMH;;;AACA,oBAAMM,yBACCD,IADD;AAEFE,iCAAaJ;AAFX,kBAAN;;AAKA,oBAAIC,YAAYI,SAAhB,EAA2B;AACvBF,8BAAUG,cAAV,GAA2BL,OAA3B;AACH;;AAED;AACA;AACA,uBAAOH,QAAQS,IAAR,CACH,kBAAU;AACN;AACA;AACAX,0CACOO,SADP;AAEIH,8BAAMA,OAAO,UAFjB;AAGIC,iCAASO;AAHb;;AAMA;AACA,2BAAO,IAAP;AACH,iBAZE,EAaH,iBAAS;AACLC,4BAAQC,KAAR,CAAcA,KAAd;;AAEAd,0CACOO,SADP;AAEIH,8BAAMA,OAAO,UAFjB;AAGIC,iCAASS;AAHb;;AAMA;AACA,2BAAO,KAAP;AACH,iBAxBE,CAAP;AA0BH;AACJ,SAnDM;AAAA,KAAP;AAoDH","file":"promiseMiddleware.js","sourcesContent":["/**\n * Created by lerayne on 17.01.17.\n */\n\n/**\n * Redux middleware that performs Promise functionality.\n * @param getState\n * @param dispatch\n * @returns function\n */\nexport default function promiseMiddleware({getState, dispatch}) {\n    return next => action => {\n\n        // Expects action to have \"promise\" field.\n        // If none - throws it to next middleware with correct return policy.\n        if (!action.promise) {\n            return next(action)\n        } else {\n            // Pass the action itself to the next MW transparently (allows to do smthng on request)\n            next(action)\n\n            const {type, promise, payload, ...rest} = action\n\n            // copy all initial info to a new action\n            const newAction = {\n                ...rest,\n                initialType: type,\n            }\n\n            if (payload !== undefined) {\n                newAction.initialPayload = payload\n            }\n\n            // Returns a promise in which this \"then\" is done and the next \"then\" will receive the\n            // result of this\n            return promise.then(\n                result => {\n                    // \"next\" is fatser, but \"dispatch\" is more correct, for example there can be\n                    // loogger middleware\n                    dispatch({\n                        ...newAction,\n                        type: type + '_SUCCESS',\n                        payload: result\n                    })\n\n                    // this is passed into next \"then\"\n                    return true\n                },\n                error => {\n                    console.error(error)\n\n                    dispatch({\n                        ...newAction,\n                        type: type + '_FAILURE',\n                        payload: error\n                    })\n\n                    // this is passed into next \"then\"\n                    return false\n                }\n            )\n        }\n    }\n}"]}