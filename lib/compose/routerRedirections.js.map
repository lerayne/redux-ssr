{"version":3,"sources":["../../src/compose/routerRedirections.js"],"names":["createRouterRedirectFuncs","getRedirectUrl","pathname","prevLocation","urlObject","query","next","search","url","format","isLoggedInFromState","loginPagePath","rootPath","redirectionCheck","getState","nextRouterState","redirect","routes","location","userLoggedIn","redirected","forEach","component","route","WrappedComponent","loginRequired","anonymousRequired","getOnEnterFunc","isServer","console","log","getOnChangeFunc","prevRouterState"],"mappings":"AAAA;;;AAGA;;;;;QA+BgBA,yB,GAAAA,yB;;AA7BhB;;;;AACA;;;;;;AAEA;;;;;;;AAOA,SAASC,cAAT,CAAwBC,QAAxB,EAAwD;AAAA,QAAtBC,YAAsB,uEAAP,KAAO;;AACpD,QAAMC,YAAY;AACdF,kBAAUA,QADI;AAEdG,eAAO;AAFO,KAAlB;;AAKA,QAAIF,YAAJ,EAAkB;AACdC,kBAAUC,KAAV,CAAgBC,IAAhB,GAAuBH,aAAaD,QAAb,GAAwBC,aAAaI,MAA5D;AACH;;AAED,WAAOC,cAAIC,MAAJ,CAAWL,SAAX,CAAP;AACH;;AAED;;;;;;AAMO,SAASJ,yBAAT,CAAmCU,mBAAnC,EAAwDC,aAAxD,EAAuEC,QAAvE,EAAgF;AACnF;;;;;;;;;;AAUA,aAASC,gBAAT,CAA0BC,QAA1B,EAAoCC,eAApC,EAAqDC,QAArD,EAA+D;AAAA,YAEpDC,MAFoD,GAEhCF,eAFgC,CAEpDE,MAFoD;AAAA,YAE5CC,QAF4C,GAEhCH,eAFgC,CAE5CG,QAF4C;AAG3D;AACA;AACA;;AACA,YAAMC,eAAeT,oBAAoBI,UAApB,CAArB;AACA,YAAIM,aAAa,KAAjB;;AAEAH,eAAOI,OAAP,CAAe,iBAAS;AACpB,gBAAMC,YAAYC,MAAMD,SAAN,CAAgBE,gBAAhB,IAAoCD,MAAMD,SAA5D;;AAEA,gBAAIA,UAAUG,aAAV,IAA2B,CAACN,YAAhC,EAA8C;AAC1CC,6BAAa,IAAb;AACAJ,yBAASf,eAAeU,aAAf,EAA8BO,QAA9B,CAAT;AACH;;AAED,gBAAII,UAAUI,iBAAV,IAA+BP,YAAnC,EAAiD;AAC7CC,6BAAa,IAAb;AACA;AACA;AACA;AACA;AACAJ,yBAASf,eAAeW,QAAf,CAAT;AACH;AACJ,SAhBD;;AAkBA;AACA,eAAOQ,UAAP;AACH;;AAED;;;;;;AAMA,aAASO,cAAT,CAAwBb,QAAxB,EAAkC;AAC9B,eAAO,UAAUC,eAAV,EAA2BC,QAA3B,EAAqC;AACxC,gBAAIY,oBAAJ,EAAc;AACVC,wBAAQC,GAAR,CAAY,yBAAZ;AACAjB,iCAAiBC,QAAjB,EAA2BC,eAA3B,EAA4CC,QAA5C;AACH;AACJ,SALD;AAMH;;AAED;;;;;;AAMA,aAASe,eAAT,CAAyBjB,QAAzB,EAAmC;AAC/B,eAAO,UAAUkB,eAAV,EAA2BjB,eAA3B,EAA4CC,QAA5C,EAAsD;AACzD,gBAAI,CAACY,oBAAL,EAAe;AACXC,wBAAQC,GAAR,CAAY,2BAAZ;AACA;AACA,oBAAIE,gBAAgBd,QAAhB,CAAyBhB,QAAzB,KAAsCa,gBAAgBG,QAAhB,CAAyBhB,QAAnE,EAA6E;AACzEW,qCAAiBC,QAAjB,EAA2BC,eAA3B,EAA4CC,QAA5C;AACH;AACJ;AACJ,SARD;AASH;;AAED,WAAO;AACHW,sCADG;AAEHI;AAFG,KAAP;AAIH","file":"routerRedirections.js","sourcesContent":["/**\n * Created by lerayne on 07.01.17.\n */\n\"use strict\"\n\nimport url from 'url'\nimport isServer from 'detect-node'\n\n/**\n * Creates new URL with previous location in query param \"next\"\n *\n * @param pathname: String\n * @param prevLocation: Object (URL)\n * @returns String URL\n */\nfunction getRedirectUrl(pathname, prevLocation = false) {\n    const urlObject = {\n        pathname: pathname,\n        query: {}\n    }\n\n    if (prevLocation) {\n        urlObject.query.next = prevLocation.pathname + prevLocation.search\n    }\n\n    return url.format(urlObject)\n}\n\n/**\n * @param isLoggedInFromState: Function\n * @param loginPagePath: String\n * @param rootPath: String\n * @returns {{getOnEnterFunc: function(getState): Function, getOnChangeFunc: function(getState): Function}}\n */\nexport function createRouterRedirectFuncs(isLoggedInFromState, loginPagePath, rootPath){\n    /**\n     * Check access to route container and redirect if not allowed\n     * Iterates over all components looking for \"loginRequired\" or \"anonymousRequired\" static props.\n     * redirects to \"/login\" or \"/\" if founds\n     *\n     * @param getState: Function\n     * @param nextRouterState: Object\n     * @param redirect: Function\n     * @returns {boolean}\n     */\n    function redirectionCheck(getState, nextRouterState, redirect) {\n\n        const {routes, location} = nextRouterState\n        // todo: спросиить и подумать об использовании store.getState и передаче результата вместо самой функции\n        // насколько имеет смысл вообще не передавать store в функции, а делать как в redux-thunk:\n        // передавать только getState и dispatch\n        const userLoggedIn = isLoggedInFromState(getState())\n        let redirected = false\n\n        routes.forEach(route => {\n            const component = route.component.WrappedComponent || route.component\n\n            if (component.loginRequired && !userLoggedIn) {\n                redirected = true\n                redirect(getRedirectUrl(loginPagePath, location))\n            }\n\n            if (component.anonymousRequired && userLoggedIn) {\n                redirected = true\n                // todo - подумать о том что случится, если будет переход на страницу \"login\"\n                // не при помощи набора в адрессной строке (тогда будет простой редирект), а\n                // при помощи инструментов router'а - видимо нужно перенаправить юзера откуда\n                // пришел\n                redirect(getRedirectUrl(rootPath))\n            }\n        })\n\n        // return not used\n        return redirected\n    }\n\n    /**\n     * Handle initial server authorization redirects\n     *\n     * @param getState\n     * @returns {Function}\n     */\n    function getOnEnterFunc(getState) {\n        return function (nextRouterState, redirect) {\n            if (isServer) {\n                console.log('getOnEnterFunc (SERVER)')\n                redirectionCheck(getState, nextRouterState, redirect)\n            }\n        }\n    }\n\n    /**\n     * Handle client authorization redirects\n     *\n     * @param getState\n     * @returns {Function}\n     */\n    function getOnChangeFunc(getState) {\n        return function (prevRouterState, nextRouterState, redirect) {\n            if (!isServer) {\n                console.log('getOnChangeFunc (BROWSER)')\n                // onChange is called also on url.query change, we want to omit this\n                if (prevRouterState.location.pathname !== nextRouterState.location.pathname) {\n                    redirectionCheck(getState, nextRouterState, redirect)\n                }\n            }\n        }\n    }\n\n    return {\n        getOnEnterFunc,\n        getOnChangeFunc\n    }\n}"]}