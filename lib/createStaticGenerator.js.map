{"version":3,"sources":["../src/createStaticGenerator.jsx"],"names":["createStaticGenerator","options","defaultOptions","authCookieName","loginPagePath","rootPath","keyExpiresIn","setUserState","isLoggedInFromState","requiredOptions","missingProp","find","propName","undefined","Error","getTemplate","getRootRoute","reducers","jwtSecret","domain","streamHTML","res","getState","reactNode","split","headHTML","tailHTML","write","stream","pipe","end","on","getOnEnterFunc","getOnChangeFunc","checkUserAuth","grantAccess","req","store","currentUser","payload","dispatch","location","url","routes","error","redirectLocation","renderProps","redirect","pathname","search","status","send","message","promises","forEach","component","route","WrappedComponent","initialize","push","length","Promise","all","generateStaticPage"],"mappings":"AAAA;;;AAGA;;;;;;;;;;kBAmBwBA,qB;;AAjBxB;;AACA;;AACA;;;;AACA;;AAEA;;AACA;;AACA;;;;AACA;;;;;;AASe,SAASA,qBAAT,CAA+BC,OAA/B,EAAwC;;AAEnD;;AAEA,QAAMC,iBAAiB;AACnBC,sDADmB;AAEnBC,oDAFmB;AAGnBC,0CAHmB;AAInBC,kDAJmB;AAKnBC,kDALmB;AAMnBC;AANmB,KAAvB;;AASA,QAAMC,kBAAkB,CACpB,aADoB,EAEpB,cAFoB,EAGpB,UAHoB,EAIpB,WAJoB,EAKpB,QALoB,CAAxB;;AAQA,QAAMC,cAAcD,gBAAgBE,IAAhB,CAAqB;AAAA,eAAYV,QAAQW,QAAR,MAAsBC,SAAlC;AAAA,KAArB,CAApB;;AAEA,QAAIH,WAAJ,EAAiB;AACb,cAAM,IAAII,KAAJ,sCAA6CJ,WAA7C,oBAAN;AACH;;AAEDT,2BACOC,cADP,EAEOD,OAFP;;AAKA;AACA;AAAA,uBAaQA,OAbR;AAAA,YAEQc,WAFR,YAEQA,WAFR;AAAA,YAGQC,YAHR,YAGQA,YAHR;AAAA,YAIQC,QAJR,YAIQA,QAJR;AAAA,YAKQC,SALR,YAKQA,SALR;AAAA,YAMQX,aANR,YAMQA,YANR;AAAA,YAOQC,oBAPR,YAOQA,mBAPR;AAAA,YAQQL,eARR,YAQQA,cARR;AAAA,YASQC,cATR,YASQA,aATR;AAAA,YAUQC,SAVR,YAUQA,QAVR;AAAA,YAWQC,aAXR,YAWQA,YAXR;AAAA,YAYQa,MAZR,YAYQA,MAZR;;AAeI;;;;;;;AAMA,YAAMC,aAAa,SAAbA,UAAa,CAASC,GAAT,EAAcC,QAAd,EAAwBC,SAAxB,EAAmC;AAAA,qCACrBR,YAAY,cAAZ,EAA4BO,UAA5B,EAAwCE,KAAxC,CAA8C,cAA9C,CADqB;AAAA;AAAA,gBAC3CC,QAD2C;AAAA,gBACjCC,QADiC;;AAGlDL,gBAAIM,KAAJ,CAAUF,QAAV;;AAEA,gBAAMG,SAAS,gCAAmBL,SAAnB,CAAf;;AAEAK,mBAAOC,IAAP,CAAYR,GAAZ,EAAiB,EAACS,KAAK,KAAN,EAAjB;;AAEAF,mBAAOG,EAAP,CAAU,KAAV,EAAiB,YAAM;AACnBV,oBAAIM,KAAJ,CAAUD,QAAV;AACAL,oBAAIS,GAAJ;AACH,aAHD;AAIH,SAbD;;AAeA;;AApCJ,oCAqC8C,mDACtCtB,oBADsC,EAEtCJ,cAFsC,EAGtCC,SAHsC,CArC9C;AAAA,YAqCW2B,cArCX,yBAqCWA,cArCX;AAAA,YAqC2BC,eArC3B,yBAqC2BA,eArC3B;;AAAA,+BA2CyC,2BACjCd,MADiC,EAEjChB,eAFiC,EAGjCe,SAHiC,EAIjCZ,aAJiC,CA3CzC;AAAA,YA2CW4B,aA3CX,oBA2CWA,aA3CX;AAAA,YA2C0BC,WA3C1B,oBA2C0BA,WA3C1B;;AAkDI;;;;;;;;AAMA;AAAA,+EAAO,kBAAkCC,GAAlC,EAAuCf,GAAvC;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEH;AACMgB,qCAHH,GAGW,8BAAe,EAAf,EAAmBpB,QAAnB,CAHX;;AAKH;AACA;;AANG;AAAA,uCAOkCiB,cAAcE,GAAd,CAPlC;;AAAA;AAAA;AAOaE,2CAPb,SAOIC,OAPJ;;AAAA,qCASCD,WATD;AAAA;AAAA;AAAA;;AAUCD,sCAAMG,QAAN,CAAejC,cAAa+B,WAAb,CAAf;;AAEA;AACA;AAbD;AAAA,uCAcOH,YAAYC,GAAZ,EAAiBf,GAAjB,EAAsBiB,WAAtB,CAdP;;AAAA;;AAiBH,wDAAM;AACFG,8CAAUL,IAAIM,GADZ;AAEFC,4CAAQ3B,aACJgB,eAAeK,MAAMf,QAArB,CADI,EAEJW,gBAAgBI,MAAMf,QAAtB,CAFI;AAFN,iCAAN;AAAA,wGAMG,iBAAOsB,KAAP,EAAcC,gBAAd,EAAgCC,WAAhC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6DAEKD,gBAFL;AAAA;AAAA;AAAA;;AAAA,yFAGYxB,IAAI0B,QAAJ,CAAa,GAAb,EAAkBF,iBAAiBG,QAAjB,GAA4BH,iBAAiBI,MAA/D,CAHZ;;AAAA;AAAA,6DAMKL,KANL;AAAA;AAAA;AAAA;;AAAA,yFAOYvB,IAAI6B,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqBP,MAAMQ,OAA3B,CAPZ;;AAAA;AAAA,4DAUMN,WAVN;AAAA;AAAA;AAAA;;AAAA,yFAWYzB,IAAI6B,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,WAArB,CAXZ;;AAAA;;AAcC;AACME,gEAfP,GAekB,EAflB;;;AAiBCP,oEAAYH,MAAZ,CAAmBW,OAAnB,CAA2B,iBAAS;AAChC,gEAAMC,YAAYC,MAAMD,SAAN,CAAgBE,gBAAhB,IAAoCD,MAAMD,SAA5D;AACA,gEAAIA,UAAUG,UAAd,EAA0B;AACtBL,yEAASM,IAAT,CAAcJ,UAAUG,UAAV,CAAqBrB,MAAMG,QAA3B,EAAqCM,YAAYL,QAAjD,CAAd;AACH;AACJ,yDALD;;AAOA;;AAxBD,6DAyBKY,SAASO,MAzBd;AAAA;AAAA;AAAA;;AAAA;AAAA,+DA2BWC,QAAQC,GAAR,CAAYT,QAAZ,CA3BX;;AAAA;;AA8BCjC,mEAAWC,GAAX,EAAgBgB,MAAMf,QAAtB,EACI;AAAC,gFAAD;AAAA,8DAAU,OAAOe,KAAjB;AACI,0FAAC,0BAAD,EAAmBS,WAAnB;AADJ,yDADJ;;AA9BD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qCANH;;AAAA;AAAA;AAAA;AAAA;;AAjBG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAAP;;AAAA,qBAAsBiB,kBAAtB;AAAA;AAAA;;AAAA,mBAAsBA,kBAAtB;AAAA;AA4DH;AACJ","file":"createStaticGenerator.js","sourcesContent":["/**\n * Created by lerayne on 22.12.2017.\n */\n\"use strict\"\n\nimport {match, RouterContext} from 'react-router'\nimport {Provider} from 'react-redux'\nimport React from 'react'\nimport {renderToNodeStream} from 'react-dom/server'\n\nimport {createRouterRedirectFuncs} from './compose/routerRedirections'\nimport {createAuthFuncs} from './compose/auth'\nimport configureStore from './redux/configureStore'\nimport {\n    authCookieName,\n    loginPagePath,\n    rootPath,\n    keyExpiresIn,\n    setUserState,\n    isLoggedInFromState\n} from './constants/defaultOptions'\n\nexport default function createStaticGenerator(options) {\n\n    /* object configuration */\n\n    const defaultOptions = {\n        authCookieName,\n        loginPagePath,\n        rootPath,\n        keyExpiresIn,\n        setUserState,\n        isLoggedInFromState,\n    }\n\n    const requiredOptions = [\n        'getTemplate',\n        'getRootRoute',\n        'reducers',\n        'jwtSecret',\n        'domain'\n    ]\n\n    const missingProp = requiredOptions.find(propName => options[propName] === undefined)\n\n    if (missingProp) {\n        throw new Error(`ERROR in createStaticGenerator: ${missingProp} not specified`)\n    }\n\n    options = {\n        ...defaultOptions,\n        ...options\n    }\n\n    //variable scoping\n    {\n        const {\n            getTemplate,\n            getRootRoute,\n            reducers,\n            jwtSecret,\n            setUserState,\n            isLoggedInFromState,\n            authCookieName,\n            loginPagePath,\n            rootPath,\n            keyExpiresIn,\n            domain,\n        } = options\n\n        /**\n         * return static page as a stream (allows gradual load as the page renders)\n         * @param res - express resource\n         * @param getState\n         * @param reactNode\n         */\n        const streamHTML = function(res, getState, reactNode) {\n            const [headHTML, tailHTML] = getTemplate('{react-root}', getState()).split('{react-root}')\n\n            res.write(headHTML)\n\n            const stream = renderToNodeStream(reactNode)\n\n            stream.pipe(res, {end: false})\n\n            stream.on('end', () => {\n                res.write(tailHTML)\n                res.end()\n            })\n        }\n\n        //get functions for handling redirections by react-router\n        const {getOnEnterFunc, getOnChangeFunc} = createRouterRedirectFuncs(\n            isLoggedInFromState,\n            loginPagePath,\n            rootPath\n        )\n\n        const {checkUserAuth, grantAccess} = createAuthFuncs(\n            domain,\n            authCookieName,\n            jwtSecret,\n            keyExpiresIn,\n        )\n\n        /**\n         * Actual handler of express get routing\n         *\n         * @param req - express request\n         * @param res - express response\n         */\n        return async function generateStaticPage(req, res) {\n\n            //create redux store\n            const store = configureStore({}, reducers)\n\n            // get current user's authentication cookie status (false | jwt.verify object)\n            // Attention! Only the essential user info should be stored in a JWT cookie!\n            const {payload: currentUser} = await checkUserAuth(req)\n\n            if (currentUser) {\n                store.dispatch(setUserState(currentUser))\n\n                // reauthorize user\n                // todo - only reauthorize near expiration (performance). Now reauthorizing each time\n                await grantAccess(req, res, currentUser)\n            }\n\n            match({\n                location: req.url,\n                routes: getRootRoute(\n                    getOnEnterFunc(store.getState),\n                    getOnChangeFunc(store.getState)\n                )\n            }, async (error, redirectLocation, renderProps) => {\n\n                if (redirectLocation) { // Redirect required\n                    return res.redirect(302, redirectLocation.pathname + redirectLocation.search)\n                }\n\n                if (error) { // Any error occurs\n                    return res.status(500).send(error.message)\n                }\n\n                if (!renderProps) { // Router does not recognize path\n                    return res.status(404).send('Not found')\n                }\n\n                // seeks for \"initialize\" static function that returns a promise\n                const promises = []\n\n                renderProps.routes.forEach(route => {\n                    const component = route.component.WrappedComponent || route.component\n                    if (component.initialize) {\n                        promises.push(component.initialize(store.dispatch, renderProps.location))\n                    }\n                })\n\n                // todo - proper error handling with try-catch\n                if (promises.length) {\n                    // each promise resolves only after it make all necessary changes to store\n                    await Promise.all(promises)\n                }\n\n                streamHTML(res, store.getState,\n                    <Provider store={store}>\n                        <RouterContext {...renderProps} />\n                    </Provider>\n                )\n            })\n        }\n    }\n}"]}